From 390b72b029ddee979a1e0350db8fa521bf15fb52 Mon Sep 17 00:00:00 2001
From: Jaymes Wilks <mjwilks@us.ibm.com>
Date: Mon, 11 Jan 2016 16:28:24 -0600
Subject: [PATCH] Fixup HBB address on golden side SBE in the field

This commit adds code to the SBE side actions to perform a one-time HBB fixup
on all machines that have the potential of having the golden side HBB pointer
incorrectly pointing to the primary PNOR side.  This will fix all machines out
in the field on the first boot after upgrading.

Change-Id: I416cdc95f47f15e8254b5b1391a62417470f0728
RTC:331944
ForwardPort: yes
Depends-on:I1ac3ab6a7239b2302a334bcf1f1bd7f664b7844b
Reviewed-on: http://gfw160.aus.stglabs.ibm.com:8080/gerrit/23618
Tested-by: Jenkins Server
Reviewed-by: WILLIAM G. HOFFA <wghoffa@us.ibm.com>
Tested-by: Jenkins OP Build CI
Tested-by: Jenkins OP HW
Tested-by: FSP CI Jenkins
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/include/usr/sbe/sbereasoncodes.H |   3 +-
 src/usr/sbe/sbe_resolve_sides.C      | 222 ++++++++++++++++++++++++++++++++---
 src/usr/sbe/sbe_resolve_sides.H      |  42 ++++++-
 src/usr/sbe/sbe_update.C             |  14 ++-
 src/usr/sbe/sbe_update.H             |  10 +-
 5 files changed, 259 insertions(+), 32 deletions(-)

diff --git a/src/include/usr/sbe/sbereasoncodes.H b/src/include/usr/sbe/sbereasoncodes.H
index effb69e..aae931b 100644
--- a/src/include/usr/sbe/sbereasoncodes.H
+++ b/src/include/usr/sbe/sbereasoncodes.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -60,6 +60,7 @@ enum sbeModuleId
     SBE_READ_SBE_IMAGE                  = 0x0F,
     SBE_WRITE_SBE_IMAGE                 = 0x10,
     SBE_GET_SBE_IMAGE_SIZE              = 0x11,
+    SBE_FIXUP_GOLDEN_HBB                = 0x12,
 };
 
 /**
diff --git a/src/usr/sbe/sbe_resolve_sides.C b/src/usr/sbe/sbe_resolve_sides.C
index 9c0c9d3..869aab4 100644
--- a/src/usr/sbe/sbe_resolve_sides.C
+++ b/src/usr/sbe/sbe_resolve_sides.C
@@ -425,7 +425,6 @@ errlHndl_t getSideState(sbeResolveState_t& io_sideState)
     return err;
 }
 
-
 /////////////////////////////////////////////////////////////////////
 errlHndl_t getSideActions(sbeResolveState_t& io_sideState)
 {
@@ -435,7 +434,16 @@ errlHndl_t getSideActions(sbeResolveState_t& io_sideState)
                ENTER_MRK"getSideActions()" );
 
     do{
-
+#ifdef CONFIG_PNOR_TWO_SIDE_SUPPORT
+        if (sbeGoldenHBBFixNeeded(io_sideState.tgt))
+        {
+            l_actions |= FIXUP_GOLDEN_HBB;
+            l_actions |= REIPL;
+            io_sideState.actions = l_actions;
+            // do not perform any other side actions
+            break;
+        }
+#endif
         // Check if PNOR is running from its GOLDEN side
         if ( io_sideState.pnor_isGolden == true )
         {
@@ -545,18 +553,6 @@ errlHndl_t performSideActions(sbeResolveState_t& io_sideState)
             // We need to write to the version info that the SBE Seeprom Image
             // originates from the golden side Seeprom.
 
-            // If the golden side version struct doesn't already have the newer
-            // nest_freq_mhz field add it.
-            if (image_version.struct_version < STRUCT_VERSION_NEST_FREQ)
-            {
-                TargetService& ts = targetService();
-                TARGETING::Target* sys = NULL;
-                ts.getTopLevelTarget(sys);
-
-                image_version.nest_freq_mhz =
-                                        sys->getAttr<ATTR_NEST_FREQ_MHZ>();
-            }
-
             // indicate that the version struct is the latest version
             image_version.struct_version = STRUCT_VERSION_LATEST;
 
@@ -566,6 +562,49 @@ errlHndl_t performSideActions(sbeResolveState_t& io_sideState)
             image_version.origin = GOLDEN_SIDE;
         }
 
+#ifdef CONFIG_PNOR_TWO_SIDE_SUPPORT
+        if ( io_sideState.actions & FIXUP_GOLDEN_HBB )
+        {
+            // SBE golden side images in the field may have an incorrect
+            // HBB pointer address that makes booting from the golden side pnor
+            // image impossible.
+
+            // Determine which PNOR is golden and fixup the SBE HBB pointer
+            // with it.
+            PNOR::SideId l_pnor_side = PNOR::WORKING;
+
+            if (!io_sideState.pnor_isGolden)
+            {
+                l_pnor_side = PNOR::ALTERNATE;
+            }
+
+            err = fixupSbeGoldenHBB(io_sideState.tgt,
+                                 reinterpret_cast<void*>(SBE_IMG_VADDR),
+                                 READ_ONLY_SEEPROM,
+                                 l_pnor_side,
+                                 image_size);
+            if ( err )
+            {
+                TRACFCOMP( g_trac_sbe, ERR_MRK
+                           "performSideActions: Error returned from "
+                           "fixupSbeGoldenHBB() rc=0x%.4X, "
+                           "actions = 0x%X, image_size=0x%X"
+                           "Committing Error Log eid=0x%.8X "
+                           "plid=0x%.8X for Target UID=0x%X, but "
+                           "continuing procedure",
+                           err->reasonCode(),
+                           io_sideState.actions, image_size,
+                           err->eid(),
+                           err->plid(),
+                           TARGETING::get_huid(io_sideState.tgt));
+                errlCommit( err, SBE_COMP_ID );
+                // continuing on
+                err = NULL;
+                break;
+            }
+        }
+#endif
+
         if ( io_sideState.actions & CHECK_WORKING_HBB )
         {
             // Copy current SBE Seeprom Image to Memory
@@ -588,7 +627,6 @@ errlHndl_t performSideActions(sbeResolveState_t& io_sideState)
                            io_sideState.actions, image_size);
                 break;
             }
-
         }
 
 
@@ -631,7 +669,6 @@ errlHndl_t performSideActions(sbeResolveState_t& io_sideState)
                  ( io_sideState.cur_side != READ_ONLY_SEEPROM ) )
             {
                 io_sideState.actions |= REIPL;
-
                 TRACUCOMP( g_trac_sbe, ERR_MRK
                            "performSideActions: resolveImageHBBaddr returned "
                            "updateForHBB=%d, and not on READ_ONLY_SEEPROM so "
@@ -670,6 +707,157 @@ errlHndl_t performSideActions(sbeResolveState_t& io_sideState)
     return err;
 }
 
+bool sbeGoldenHBBFixNeeded(TARGETING::Target* i_target)
+{
+    // First read the image version struct only to check if it needs fixup
+    sbeSeepromSide_t i_side = READ_ONLY_SEEPROM;
+    EEPROM::eeprom_chip_types_t l_seeprom = sbe_side_sync[i_side];
+    sbeSeepromVersionInfo_t l_image_version;
+    errlHndl_t err = NULL;
+    bool l_rc = true;
+
+    do {
+        // Read out SBE Version Info to help determing whether SBE HBB fix
+        // was performed previously
+        bool seeprom_ver_ECC_fail = false;
+
+        err = getSeepromSideVersion(i_target,
+                                    l_seeprom,
+                                    l_image_version,
+                                    seeprom_ver_ECC_fail);
+
+        if(err)
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK"sbeGoldenHBBFixNeeded: - Error "
+                       "from getSeepromSideVersion: rc=0x%.4X, seeprom=%d "
+                       "(side=%d). HUID=0x%.8X",
+                       err->reasonCode(), l_seeprom, i_side,
+                       TARGETING::get_huid(i_target));
+            break;
+        }
+        else if (seeprom_ver_ECC_fail == true)
+        {
+            // For now, any issues will be addressed in SBE Update
+            // later in the IPL
+            TRACFCOMP( g_trac_sbe, ERR_MRK"readSbeGoldenHBB: ECC fail=%d "
+                       "Reading Seeprom Version seeprom=%d "
+                       "(side=%d). HUID=0x%.8X",
+                       seeprom_ver_ECC_fail, l_seeprom, i_side,
+                       TARGETING::get_huid(i_target));
+            break;
+        }
+
+        // if fixup already occured
+        if(l_image_version.fixed || l_image_version.struct_version ==
+                                                STRUCT_VERSION_LATEST)
+        {
+            TRACFCOMP(g_trac_sbe,
+                              "SBE HBB fixup occured previously.  Skipping.");
+            l_rc = false;
+            break;
+        }
+
+        TRACFCOMP(g_trac_sbe,
+                          "SBE HBB fixup has not yet occurred.  Fixing now.");
+    } while(0);
+
+    return l_rc;
+}
+
+errlHndl_t fixupSbeGoldenHBB(TARGETING::Target* i_target,
+                        void* o_imgPtr,
+                        sbeSeepromSide_t i_side,
+                        PNOR::SideId i_pnor_side,
+                        size_t& o_image_size)
+{
+    errlHndl_t err = NULL;
+    sbeSeepromVersionInfo_t l_image_version;
+    uint8_t l_fixed_flag = 1;
+
+    do {
+        // load the entire sbe image, fixup the HBB, and update the version
+        // info struct to indicate that a fixup was done thus avoiding a repeat.
+        err = readSbeImage(i_target, o_imgPtr, i_side, o_image_size,
+                        l_image_version);
+        if (err)
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK
+                           "fixupSbeGoldenHBB: Error returned from "
+                           "readSbeImage() rc=0x%.4X, Target HUID=0x%X, ",
+                           err->reasonCode(),
+                           TARGETING::get_huid(i_target));
+            break;
+        }
+
+        // get the MMIO offset value from the side info
+        PNOR::SideInfo_t pnor_side_info;
+        err = PNOR::getSideInfo (i_pnor_side, pnor_side_info);
+        if ( err )
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK
+                       "fixupSbeGoldenHBB() - Error returned "
+                       "from PNOR::getSideInfo() rc=0x%.4X, Target HUID=0x%X "
+                       "i_pnorSideId",
+                       err->reasonCode(),
+                       TARGETING::get_huid(i_target), i_pnor_side);
+            break;
+        }
+
+        // Setting MMIO offset
+        int rc = sbe_xip_set_scalar( o_imgPtr, "standalone_mbox2_value",
+                                         pnor_side_info.hbbMmioOffset);
+        if (rc)
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK"fixupSbeGoldenHBB() - "
+                                 "sbe_xip_set_scalar() failed rc = 0x%X", rc);
+            /*@
+             * @errortype
+             * @moduleid     SBE_FIXUP_GOLDEN_HBB
+             * @reasoncode   SBE_IMAGE_GET_SET_SCALAR_FAIL
+             * @userdata1    Return Code of failed operation
+             * @devdesc      sbe_xip_get/set_scalar() failed when accessing the
+             * HBB Address MMIO offset in 'standalone_mbox2_value'
+             * @custdesc     A problem occurred while updating processor
+             * boot code.
+             */
+            err = new ErrlEntry(ERRL_SEV_INFORMATIONAL,
+                            SBE_FIXUP_GOLDEN_HBB,
+                            SBE_IMAGE_GET_SET_SCALAR_FAIL,
+                            TO_UINT64(rc),
+                            true /*Add HB SW Callout*/ );
+
+            err->collectTrace(SBE_COMP_NAME);
+            errlCommit( err, SBE_COMP_ID );
+            l_fixed_flag = 2;  // error in TOC bread crumb
+
+            // We do not break here.  We want to write the image version struct
+            // even if the call to sbe_xip_set_scalar failed.  In such a case
+            // we will increment the "fixed" flag from 1 to 2.  See below.
+        }
+
+        // indicate that the version struct is the latest version
+        l_image_version.struct_version = STRUCT_VERSION_LATEST;
+
+        // Set the fixed flag
+        l_image_version.fixed = l_fixed_flag;  // 1: success  2: error in TOC
+
+        // Finally, write the entire SBE image to the golden side SBE seeprom.
+        err = writeSbeImage(i_target, o_imgPtr, i_side, o_image_size,
+                                l_image_version);
+        if ( err )
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK
+                           "fixupSbeGoldenHBB: Error returned from "
+                           "writeSbeImage() rc=0x%.4X, Target UID=0x%X, ",
+                           err->reasonCode(),
+                           TARGETING::get_huid(i_target));
+            break;
+        }
+
+    } while (0);
+
+    return err;
+}
 
 /////////////////////////////////////////////////////////////////////
 errlHndl_t readSbeImage(TARGETING::Target* i_target,
@@ -1179,8 +1367,6 @@ errlHndl_t getSbeImageSize(TARGETING::Target* i_target,
     return err;
 }
 
-
-
 /////////////////////////////////////////////////////////////////////
 errlHndl_t resolveImageHBBaddr(TARGETING::Target* i_target,
                                void* io_imgPtr,
diff --git a/src/usr/sbe/sbe_resolve_sides.H b/src/usr/sbe/sbe_resolve_sides.H
index 25d442e..e336810 100644
--- a/src/usr/sbe/sbe_resolve_sides.H
+++ b/src/usr/sbe/sbe_resolve_sides.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2015                             */
+/* Contributors Listed Below - COPYRIGHT 2015,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -70,6 +70,10 @@ namespace SBE
         // NOTE: These next 2 values are mutually exclusive
         CHECK_WORKING_HBB         = 0x00000010,
         COPY_READ_ONLY_TO_WORKING = 0x00000020,
+
+        // NOTE: This must be performed on its own IPL and
+        // only makes sense on machines with a two-sided PNOR
+        FIXUP_GOLDEN_HBB          = 0x00000040,
     };
 
     /******************************************/
@@ -138,6 +142,16 @@ namespace SBE
      */
     errlHndl_t performSideActions(sbeResolveState_t& io_sideState);
 
+    /**
+     * @brief Determines whether the Golden HBB Pointer Fix has happened
+     * previously on this sytem and returns true if it has.
+     *
+     * @param[in] i_target The SBE target that this fix applies to.
+     *
+     * @return bool  Returns true if the fix is needed and false it it was
+     * already applied.
+     */
+    bool sbeGoldenHBBFixNeeded(TARGETING::Target* i_target);
 
 
     /******************************************/
@@ -204,7 +218,7 @@ namespace SBE
      *
      * @param[in] i_target   Target processor
      *
-     * @param[out] i_imgPtr    Pointer to pre-allocated memory to be used
+     * @param[in] i_imgPtr    Pointer to pre-allocated memory to be used
      *                         for different operations
      *
      * @param[in] i_side          Seeprom Side to access
@@ -218,8 +232,28 @@ namespace SBE
                                sbeSeepromSide_t i_side,
                                size_t& o_image_size);
 
-
-
+    /**
+     * @brief Check if a given SBE side has the correct HBB pointer and
+     *        perform fixup if it is invalid
+     *
+     * @param[in] i_target   Target processor
+     *
+     * @param[in] i_imgPtr    Pointer to pre-allocated memory to be used
+     *                         for different operations
+     *
+     * @param[in] i_side          Seeprom Side to access
+     *
+     * @param[in] i_pnor_side     PNOR Side to access
+     *
+     * @param[out] o_image_size    The size of the image (non-ECC)
+     *
+     * @return errlHndl_t    Error log handle on failure.
+     */
+     errlHndl_t fixupSbeGoldenHBB(TARGETING::Target* i_target,
+                               void* i_imgPtr,
+                               sbeSeepromSide_t i_side,
+                               PNOR::SideId i_pnor_side,
+                               size_t& o_image_size);
 
     /******************************************/
     /*  Functions -- Helper Functions         */
diff --git a/src/usr/sbe/sbe_update.C b/src/usr/sbe/sbe_update.C
index 4b1d477..f4d0d7f 100644
--- a/src/usr/sbe/sbe_update.C
+++ b/src/usr/sbe/sbe_update.C
@@ -1668,7 +1668,7 @@ namespace SBE
 
 
             if ( o_info.struct_version >= STRUCT_VERSION_CRC &&
-                 o_info.struct_version <= STRUCT_VERSION_ORIGIN_GOLD )
+                 o_info.struct_version <= STRUCT_VERSION_LATEST )
             {
                 // Supported Versions - set size variable to remove ECC
                 sbeInfoSize = SBE_SEEPROM_STRUCT_SIZES[o_info.struct_version];
@@ -1699,8 +1699,7 @@ namespace SBE
             // clear data and set o_seeprom_ver_ECC_fail=true
             if ( eccStatus == PNOR::ECC::UNCORRECTABLE )
             {
-
-                TRACFCOMP( g_trac_sbe,ERR_MRK"getSeepromSideVersion() - ECC "
+                TRACFCOMP( g_trac_sbe, ERR_MRK"getSeepromSideVersion() - ECC "
                            "ERROR: Handled. eccStatus=%d, side=%d, sizeof "
                            "o_info/sI=%d, sI_ECC=%d",
                            eccStatus, i_seepromSide, sbeInfoSize,
@@ -4088,7 +4087,8 @@ namespace SBE
 
         // Check Seeprom
         if ( i_struct_version >= STRUCT_VERSION_NEST_FREQ &&
-             i_struct_version <= STRUCT_VERSION_ORIGIN_GOLD )
+             i_struct_version <= STRUCT_VERSION_LATEST &&
+             i_seeprom_nest_freq != 0 )
         {
             // Only version that tracks the nest freq when the image was
             // customized
@@ -4212,7 +4212,8 @@ namespace SBE
                     if ( io_sbeState.seeprom_0_ver.struct_version >=
                             STRUCT_VERSION_NEST_FREQ &&
                          io_sbeState.seeprom_0_ver.struct_version <=
-                            STRUCT_VERSION_ORIGIN_GOLD )
+                            STRUCT_VERSION_LATEST &&
+                         io_sbeState.seeprom_0_ver.nest_freq_mhz != 0 )
                     {
                         io_sbeState.mproc_nest_freq_mhz =
                                     io_sbeState.seeprom_0_ver.nest_freq_mhz;
@@ -4228,7 +4229,8 @@ namespace SBE
                     if ( io_sbeState.seeprom_1_ver.struct_version >=
                             STRUCT_VERSION_NEST_FREQ &&
                          io_sbeState.seeprom_1_ver.struct_version <=
-                            STRUCT_VERSION_ORIGIN_GOLD )
+                            STRUCT_VERSION_LATEST &&
+                         io_sbeState.seeprom_1_ver.nest_freq_mhz != 0 )
                     {
                         io_sbeState.mproc_nest_freq_mhz =
                                     io_sbeState.seeprom_1_ver.nest_freq_mhz;
diff --git a/src/usr/sbe/sbe_update.H b/src/usr/sbe/sbe_update.H
index 46eccfe..3fc5086 100644
--- a/src/usr/sbe/sbe_update.H
+++ b/src/usr/sbe/sbe_update.H
@@ -44,7 +44,7 @@ namespace SBE
     const size_t   SBE_MVPD_SHORT_IMAGE_VERSION_SIZE = 20;
 
     // Number of versions supported
-    const uint8_t SBE_SEEPROM_STRUCT_MAX_VERSIONS    = 0x04;
+    const uint8_t SBE_SEEPROM_STRUCT_MAX_VERSIONS    = 0x05;
 
     // Size of supported versions - must be 8-byte aligned
     const size_t  SBE_SEEPROM_STRUCT_SIZES[SBE_SEEPROM_STRUCT_MAX_VERSIONS] =
@@ -53,6 +53,7 @@ namespace SBE
                         72,  // ver1: size of struct is 72 bytes
                         80,  // ver2: size of struct is 80 bytes
                         80,  // ver3: size of struct is 80 bytes
+                        80,  // ver4: size of struct is 80 bytes
                       };
 
     // This enum provides the struct versions for sbeSeepromVersionInfo_t
@@ -61,7 +62,8 @@ namespace SBE
         STRUCT_VERSION_CRC = 0x1,
         STRUCT_VERSION_NEST_FREQ = 0x2,
         STRUCT_VERSION_ORIGIN_GOLD = 0x3,
-        STRUCT_VERSION_LATEST = 0x3,
+        STRUCT_VERSION_HBB_FIXUP = 0x4,
+        STRUCT_VERSION_LATEST = 0x4,
         STRUCT_VERSION_SIMICS = 0x5A5A5A5A,
     };
 
@@ -179,7 +181,9 @@ namespace SBE
         uint32_t  nest_freq_mhz;
         // New parameters for version 3: origin set if SBE came from golden side
         uint8_t   origin;
-        uint8_t   unused[3]; // unused space
+        // New parameters for version 4: fixed set if fixup of HBB occured
+        uint8_t   fixed;
+        uint8_t   unused[2]; // unused space
     } PACKED;
 
     // This line forces a compile fail if struct is NOT 8-byte-alaigned
