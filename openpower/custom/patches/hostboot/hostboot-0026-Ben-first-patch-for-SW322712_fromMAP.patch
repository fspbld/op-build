From 4e30c656bdbe40ebd597152a37a7e5365405ebc6 Mon Sep 17 00:00:00 2001
From: Ben Rafanello <brafanel@us.ibm.com>
Date: Thu, 15 Oct 2015 17:02:00 -0500
Subject: [PATCH] SW322712: Missing SEL for L3 Checkstop Error

The problem in this defect is that a race condition develops between
the IPMISel thread (which transmits eSEL and SEL data to the BMC) and
the thread running shutdown.  This occurs when the first error
that generates an eSEL is a fatal error.  Normally, IPMISel is created
well before shutdown and has a chance to register for shutdown
notification, which will allow it to complete the sending of any
data in its queue as part of the shutdown process.  But, when the
first error encountered is a fatal error, then IPMISel may not be
able to register for shutdown notification before the shutdown
process is started.  This happens because the thread which creates
the IPMISel thread is also the thread that goes on to run shutdown.
If IPMISel does not get a time slice before shutdown is run, then
it can't register to become part of the shutdown process, in which
case, it becomes a race to see how much data IPMISel can send to the
BMC before shutdown reboots the machine.

The fix implemented here is simply to change when the IPMISel thread
is created.  Instead of creating the IPMISel thread when the first
error is encountered, it is being started very early by IPMIRP.

I tested this fix on a firestone system using instructions provided
by the submitter of the defect.

Change-Id: Ie25a5c6e81580375fd18dfe4431660ca14f78273
CQ:SW322712
---
 src/usr/ipmi/ipmirp.C | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/usr/ipmi/ipmirp.C b/src/usr/ipmi/ipmirp.C
index fb542bc..bfb82ef 100644
--- a/src/usr/ipmi/ipmirp.C
+++ b/src/usr/ipmi/ipmirp.C
@@ -49,6 +49,9 @@
 #include <sys/misc.h>
 #include <errno.h>
 
+#include <ipmi/ipmisel.H>
+
+
 #include <console/consoleif.H>
 // Defined in ipmidd.C
 extern trace_desc_t * g_trac_ipmi;
@@ -560,6 +563,8 @@ void IpmiRP::execute(void)
     // call ErrlManager function - tell him that IPMI is ready!
     ERRORLOG::ErrlManager::errlResourceReady(ERRORLOG::IPMI);
 
+    Singleton<IpmiSEL>::instance();
+
     while (true)
     {
         msg_t* msg = msg_wait(iv_msgQ);
-- 
1.8.2.2

